<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Omeka S to Wikidata - Property Mapper</title>
    <link rel="stylesheet" href="style.css">
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            margin: 0;
            padding: 20px;
            background-color: #f9f9f9;
        }
        
        h1, h2, h3 {
            color: #2c3e50;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .file-import {
            margin-bottom: 20px;
            padding: 20px;
            border: 1px dashed #ccc;
            border-radius: 5px;
            background-color: #f5f5f5;
        }
        
        .file-import-inner {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            text-align: center;
        }
        
        .file-import-inner p {
            margin-bottom: 10px;
        }
        
        #drop-area {
            width: 100%;
            height: 100px;
            border: 2px dashed #3498db;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 15px;
            background-color: #ecf0f1;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        #drop-area:hover {
            background-color: #d6eaf8;
        }
        
        #file-input {
            display: none;
        }
        
        .button {
            padding: 8px 16px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        
        .button:hover {
            background-color: #2980b9;
        }
        
        .button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        
        .table-container {
            overflow-x: auto;
            margin-bottom: 20px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        
        th, td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        
        th {
            background-color: #f2f2f2;
            position: sticky;
            top: 0;
        }
        
        tr:hover {
            background-color: #f5f5f5;
        }
        
        .property-card {
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-bottom: 15px;
            overflow: hidden;
        }
        
        .property-header {
            background-color: #f0f7ff;
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            border-bottom: 1px solid #ddd;
        }
        
        .property-header h3 {
            margin: 0;
            font-size: 16px;
        }
        
        .property-header .prefix-badge {
            background-color: #3498db;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
            margin-left: 10px;
        }
        
        .property-content {
            padding: 15px;
            display: none;
        }
        
        .property-content.active {
            display: block;
        }
        
        .uri-link {
            display: block;
            word-break: break-all;
            margin-bottom: 10px;
            color: #3498db;
            text-decoration: none;
        }
        
        .uri-link:hover {
            text-decoration: underline;
        }
        
        .sample-values {
            margin-top: 15px;
        }
        
        .sample-value {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
        }
        
        .json-view {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 10px;
            margin-top: 10px;
            white-space: pre-wrap;
            font-family: monospace;
            max-height: 200px;
            overflow: auto;
        }
        
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-bottom: none;
            margin-right: 5px;
            border-radius: 5px 5px 0 0;
        }
        
        .tab.active {
            background-color: white;
            border-bottom: 1px solid white;
            margin-bottom: -1px;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .mapping-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        
        .mapping-column {
            flex: 1;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            overflow: hidden;
            min-width: 0; /* Important for flex children */
        }
        
        .mapping-header {
            background-color: #f2f2f2;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-weight: bold;
            text-align: center;
        }
        
        .mapping-item {
            display: flex;
            align-items: center;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 8px;
            cursor: move;
            background-color: white;
            transition: background-color 0.2s;
            max-width: 100%;
            overflow: hidden;
        }
        
        .mapping-item:hover {
            background-color: #f5f5f5;
        }
        
        .mapping-item-uri {
            font-size: 12px;
            color: #666;
            margin-top: 4px;
            max-width: 100%;
            word-wrap: break-word;
            word-break: break-word;
        }
        
        .mapping-item-content {
            flex: 1;
            min-width: 0;  /* Important for flex children with text overflow */
            overflow: hidden;
        }
        
        .droppable-area {
            min-height: 100px;
            max-height: 400px;
            padding: 10px;
            border: 1px dashed #ccc;
            margin-top: 15px;
            transition: background-color 0.2s;
            overflow-y: auto;
        }
        
        .property-search {
            margin-bottom: 15px;
        }
        
        .property-search input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .wikidata-search {
            margin-bottom: 15px;
            position: relative;
        }
        
        .wikidata-search input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .wikidata-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 0 0 4px 4px;
            margin-top: -1px;
            background-color: white;
            z-index: 100;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            display: none;
        }
        
        .wikidata-results.active {
            display: block;
        }
        
        .wikidata-result-item {
            padding: 8px 12px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
        }
        
        .wikidata-result-item:last-child {
            border-bottom: none;
        }
        
        .wikidata-result-item:hover {
            background-color: #f5f5f5;
        }
        
        .wikidata-property-id {
            font-weight: bold;
            margin-right: 5px;
        }
        
        .wikidata-property-description {
            font-size: 12px;
            color: #666;
            margin-top: 3px;
            word-wrap: break-word;
            word-break: break-word;
        }
        
        .wikidata-search-status {
            position: absolute;
            top: 50%;
            right: 10px;
            transform: translateY(-50%);
            color: #999;
            font-size: 12px;
        }
        
        .export-section {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
        }
        
        .centered {
            text-align: center;
        }
        
        /* New styles for documentation and usability */
        .intro-section {
            margin-bottom: 30px;
            padding: 20px;
            background-color: #f9f9f9;
            border-radius: 8px;
            border-left: 5px solid #3498db;
        }
        
        .workflow-steps {
            margin: 20px 0;
        }
        
        .steps-list li {
            margin-bottom: 15px;
            line-height: 1.5;
        }
        
        .benefits ul {
            list-style-type: none;
            padding-left: 0;
        }
        
        .benefits li {
            padding: 8px 0 8px 25px;
            position: relative;
        }
        
        .benefits li:before {
            content: "✓";
            position: absolute;
            left: 0;
            color: #2ecc71;
            font-weight: bold;
        }
        
        .file-format-note {
            font-size: 12px;
            color: #666;
            margin-top: 15px;
        }
        
        /* Entity Schema section styles */
        .entity-schema-section {
            background-color: #f0f8ff;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            border-left: 3px solid #3498db;
        }
        
        .entity-schema-search {
            margin: 10px 0;
            position: relative;
        }
        
        .entity-schema-search input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .entity-schema-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
        }
        
        #current-schema-name {
            font-weight: bold;
            margin: 0;
        }
        
        /* Schema properties styling */
        .wikidata-properties-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .schema-properties {
            border: 2px solid #ffd700;
            background-color: #fffdf0;
        }
        
        .schema-properties h4 {
            color: #8B6914;
            border-bottom: 1px solid #ffd700;
            padding-bottom: 8px;
            margin-top: 0;
        }
        
        .schema-properties-info {
            font-style: italic;
            color: #8B6914;
            font-size: 0.9em;
            margin-top: 0;
            margin-bottom: 15px;
        }
        
        #schema-properties-title {
            font-weight: bold;
        }
        
        .tab-instructions {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f5f5f5;
            border-radius: 5px;
        }
        
        .mapping-tips {
            margin: 15px 0;
            padding: 10px 15px;
            background-color: #fff8e1;
            border-left: 3px solid #ffc107;
            border-radius: 0 5px 5px 0;
        }
        
        .result-instructions {
            margin-bottom: 20px;
        }
        
        .export-note {
            font-size: 13px;
            color: #666;
            margin-top: 10px;
        }
        
        .success-message {
            padding: 15px;
            background-color: #d4edda;
            border-radius: 5px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .success-icon {
            color: #28a745;
            font-style: normal;
            font-weight: bold;
            margin-right: 5px;
        }
        
        /* Add label with property counts */
        .property-count {
            font-size: 12px;
            color: #777;
            margin-left: 5px;
        }
        
        /* Better visibility for draggable items */
        .mapping-item.dragging {
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Omeka S to Wikidata Property Mapper</h1>
        
        <div class="intro-section">
            <h2>Welkom bij de Property Mapper Tool</h2>
            <p>
                Met deze tool kun je eigenschappen (properties) uit Omeka S koppelen aan Wikidata-eigenschappen om gestructureerde data te integreren.
                Dit maakt het mogelijk om informatie van verschillende bronnen samen te brengen en de zichtbaarheid van je collectie te vergroten.
            </p>
            
            <div class="workflow-steps">
                <h3>Hoe werkt het?</h3>
                <ol class="steps-list">
                    <li>
                        <strong>Upload een property-bestand</strong> - Begin met het uploaden van een JSON-bestand dat is geëxporteerd vanuit de Omeka S API viewer. 
                        Dit bestand bevat informatie over de eigenschappen (properties) in je Omeka S-collectie.
                    </li>
                    <li>
                        <strong>Bekijk de eigenschappen</strong> - Na het uploaden zie je een lijst van alle Omeka S-eigenschappen, inclusief hun URI's, namespaces, en voorbeeldwaarden.
                    </li>
                    <li>
                        <strong>Automatische suggesties</strong> - De tool zoekt automatisch naar passende Wikidata-eigenschappen op basis van de Linked Open Data URI's in je bestand.
                    </li>
                    <li>
                        <strong>Koppel eigenschappen</strong> - Sleep eigenschappen van Omeka S naar Wikidata-eigenschappen om ze te koppelen, of zoek handmatig naar extra Wikidata-eigenschappen.
                    </li>
                    <li>
                        <strong>Exporteer de mapping</strong> - Wanneer je klaar bent, kun je de gemaakte koppelingen exporteren als JSON-bestand voor toekomstig gebruik.
                    </li>
                </ol>
            </div>
            
            <div class="benefits">
                <h3>Voordelen van property mapping</h3>
                <ul>
                    <li><strong>Verbeterde zichtbaarheid</strong> - Koppel je collectie aan het grotere kennisnetwerk van Wikidata</li>
                    <li><strong>Standaardisatie</strong> - Gebruik internationaal erkende identificaties voor je metadata</li>
                    <li><strong>Interoperabiliteit</strong> - Maak je data begrijpelijk voor andere systemen en projecten</li>
                    <li><strong>Verrijking</strong> - Voeg context en verbanden toe aan je collectie</li>
                </ul>
            </div>
        </div>

        <div id="file-import" class="file-import">
            <div class="file-import-inner">
                <h3>Begin met het importeren van je eigenschappen</h3>
                <p>Kies een JSON-bestand met Omeka S properties om te importeren:</p>
                <div id="drop-area">
                    <p>Sleep bestand hierheen of klik om te bladeren</p>
                </div>
                <input type="file" id="file-input" accept=".json">
                <button id="browse-button" class="button">Bladeren</button>
                <p class="file-format-note">
                    <i>Opmerking: Het bestand moet in JSON-formaat zijn en een array van 'properties' bevatten, 
                    geëxporteerd vanuit de Omeka S API viewer met de "Property View" optie.</i>
                </p>
            </div>
        </div>

        <div id="loaded-data" style="display:none;">
            <div class="success-message">
                <p><i class="success-icon">✓</i> Bestand succesvol geladen! Je kunt nu werken met de eigenschappen.</p>
                <button id="load-another-file" class="button">Laad een ander bestand</button>
            </div>
            
            <div class="tabs">
                <div class="tab active" data-tab="properties-tab">Eigenschappen Lijst</div>
                <div class="tab" data-tab="mapping-tab">Eigenschappen Koppelen</div>
            </div>

            <div class="tab-content active" id="properties-tab">
                <div class="tab-instructions">
                    <h3>Overzicht van Omeka S-eigenschappen</h3>
                    <p>
                        Hieronder zie je alle eigenschappen uit het geïmporteerde bestand. Gebruik de zoekbalk om specifieke eigenschappen te vinden.
                        Klik op een eigenschap om details te bekijken, zoals de URI, namespace en voorbeeldwaarden.
                    </p>
                </div>
                
                <div class="property-search">
                    <label for="property-filter">Zoek eigenschappen:</label>
                    <input type="text" id="property-filter" placeholder="Filter op naam, prefix of URI...">
                </div>
                
                <div id="properties-container"></div>
            </div>

            <div class="tab-content" id="mapping-tab">
                <div class="tab-instructions">
                    <h3>Koppel Omeka S-eigenschappen aan Wikidata</h3>
                    <p>
                        Op dit tabblad kun je Omeka S-eigenschappen koppelen aan corresponderende Wikidata-eigenschappen.
                        De tool heeft al automatisch gezocht naar overeenkomende eigenschappen, maar je kunt ook handmatig koppelingen maken.
                    </p>
                    
                    <div class="mapping-tips">
                        <h4>Tips voor het koppelen:</h4>
                        <ul>
                            <li><strong>Sleep en drop</strong> - Sleep een Omeka S-eigenschap naar een Wikidata-eigenschap om ze te koppelen</li>
                            <li><strong>Bidirectioneel</strong> - Je kunt ook een Wikidata-eigenschap naar een Omeka S-eigenschap slepen</li>
                            <li><strong>Zoeken</strong> - Gebruik de zoekbalk om snel Wikidata-eigenschappen te vinden op basis van naam of ID (zoals "P50")</li>
                            <li><strong>Scrollen</strong> - Beide kolommen kunnen onafhankelijk scrollen om eigenschappen te vinden</li>
                        </ul>
                    </div>
                </div>
                
                <div class="mapping-container">
                    <div class="mapping-column">
                        <div class="mapping-header">Omeka S-eigenschappen</div>
                        <div class="property-search">
                            <input type="text" id="omeka-property-filter" placeholder="Filter Omeka-eigenschappen...">
                        </div>
                        <div id="omeka-properties" class="droppable-area" data-type="omeka"></div>
                    </div>
                    <div class="mapping-column">
                        <div class="mapping-header">Wikidata-eigenschappen</div>
                        
                        <div class="entity-schema-section">
                            <h4>Wikidata Entity Schema</h4>
                            <p>Selecteer een Entity Schema om relevante eigenschappen te laden:</p>
                            <div class="entity-schema-search">
                                <input type="text" id="entity-schema-search" placeholder="Zoek een schema (bijv. E471)..." value="E471">
                                <span id="entity-schema-status" class="wikidata-search-status"></span>
                                <div id="entity-schema-results" class="wikidata-results"></div>
                            </div>
                            <div class="entity-schema-info">
                                <p id="current-schema-name">Individual copy of a book (E471)</p>
                                <button id="load-schema-properties" class="button">Laad eigenschappen van schema</button>
                            </div>
                        </div>
                        
                        <div class="wikidata-search">
                            <input type="text" id="wikidata-search" placeholder="Typ om Wikidata-eigenschappen te zoeken...">
                            <span id="wikidata-search-status" class="wikidata-search-status"></span>
                            <div id="wikidata-results" class="wikidata-results"></div>
                        </div>
                        <div class="wikidata-properties-container">
                            <div id="schema-properties" class="droppable-area schema-properties" data-type="wikidata">
                                <h4>Eigenschappen van Entity Schema <span id="schema-properties-title">E471</span></h4>
                                <p class="schema-properties-info">Deze eigenschappen zijn de gouden standaard volgens het gekozen Entity Schema</p>
                            </div>
                            <div id="selected-wikidata-properties" class="droppable-area" data-type="wikidata">
                                <h4>Overige geselecteerde eigenschappen</h4>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="export-section">
                    <h3 class="centered">Mappingresultaten</h3>
                    <div class="result-instructions">
                        <p>
                            Hieronder zie je alle gemaakte koppelingen tussen Omeka S en Wikidata.
                            Deze koppelingen kunnen worden geëxporteerd als JSON-bestand voor gebruik in andere applicaties.
                        </p>
                    </div>
                    <div id="mapping-results">
                        <p class="centered">Nog geen koppelingen gemaakt. Sleep Omeka S-eigenschappen naar Wikidata-eigenschappen om koppelingen te maken.</p>
                    </div>
                    <div class="centered">
                        <button id="export-mapping" class="button" disabled>Exporteer Mapping</button>
                        <p class="export-note">Het geëxporteerde bestand bevat alle koppelingen en kan worden gebruikt voor de integratie van Omeka S en Wikidata-gegevens.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // DOM elements
            const dropArea = document.getElementById('drop-area');
            const fileInput = document.getElementById('file-input');
            const browseButton = document.getElementById('browse-button');
            const loadedDataSection = document.getElementById('loaded-data');
            const propertiesContainer = document.getElementById('properties-container');
            const propertyFilter = document.getElementById('property-filter');
            const omekaPropertyFilter = document.getElementById('omeka-property-filter');
            const omekaPropertiesContainer = document.getElementById('omeka-properties');
            const wikidataSearch = document.getElementById('wikidata-search');
            const wikidataSearchBtn = document.getElementById('wikidata-search-btn');
            const wikidataResults = document.getElementById('wikidata-results');
            const wikidataSearchStatus = document.getElementById('wikidata-search-status');
            const exportMappingBtn = document.getElementById('export-mapping');
            const entitySchemaSearch = document.getElementById('entity-schema-search');
            const entitySchemaResults = document.getElementById('entity-schema-results');
            const entitySchemaStatus = document.getElementById('entity-schema-status');
            const currentSchemaName = document.getElementById('current-schema-name');
            const loadSchemaPropertiesBtn = document.getElementById('load-schema-properties');
            const tabs = document.querySelectorAll('.tab');
            const tabContents = document.querySelectorAll('.tab-content');

            // Store loaded data
            let propertiesData = null;
            let mappingData = {};
            let currentSchemaId = 'E471'; // Default schema

            // Set up drag and drop functionality
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            // Make droppable areas handle drops
            document.querySelectorAll('.droppable-area').forEach(area => {
                area.addEventListener('dragover', allowDrop);
                area.addEventListener('drop', handleDrop);
                area.addEventListener('dragleave', function(e) {
                    this.style.backgroundColor = '';
                });
            });

            // Highlight drop area when dragging over it
            ['dragenter', 'dragover'].forEach(eventName => {
                dropArea.addEventListener(eventName, highlight, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, unhighlight, false);
            });

            function highlight() {
                dropArea.style.backgroundColor = '#d6eaf8';
            }

            function unhighlight() {
                dropArea.style.backgroundColor = '#ecf0f1';
            }

            // Handle file drop
            dropArea.addEventListener('drop', handleDrop, false);
            
            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                handleFiles(files);
            }

            // Handle file input change
            fileInput.addEventListener('change', function() {
                handleFiles(this.files);
            });

            // Connect the browse button to the file input
            browseButton.addEventListener('click', function() {
                fileInput.click();
            });

            // Process uploaded files
            function handleFiles(files) {
                if (files.length) {
                    const file = files[0];
                    if (file.type === 'application/json' || file.name.endsWith('.json')) {
                        readFile(file);
                    } else {
                        alert('Please upload a JSON file.');
                    }
                }
            }

            // Read the JSON file
            function readFile(file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        loadProperties(data);
                    } catch (error) {
                        alert('Error parsing JSON file: ' + error.message);
                    }
                };
                reader.readAsText(file);
            }

            // Load the properties from the JSON data
            function loadProperties(data) {
                if (data && data.properties && Array.isArray(data.properties)) {
                    propertiesData = data;
                    renderProperties(data.properties);
                    renderOmekaProperties(data.properties);
                    
                    // Hide the file import section and show the loaded data section
                    document.getElementById('file-import').style.display = 'none';
                    loadedDataSection.style.display = 'block';
                    
                    // Auto-populate Wikidata properties based on LOD URIs
                    autoPopulateWikidataProperties(data.properties);
                    
                    // Add event listener for "Load another file" button
                    document.getElementById('load-another-file').addEventListener('click', function() {
                        document.getElementById('file-import').style.display = 'block';
                        document.getElementById('file-input').value = '';
                    });
                } else {
                    alert('Ongeldig JSON-formaat. Het bestand moet een array van eigenschappen (properties) bevatten.');
                }
            }
            
            // Function to automatically find matching Wikidata properties for LOD URIs
            function autoPopulateWikidataProperties(properties) {
                // Extract all unique URIs
                const uris = properties
                    .filter(p => p.uri)
                    .map(p => p.uri);
                
                if (uris.length === 0) {
                    return;
                }
                
                // Create a status message
                const statusEl = document.createElement('div');
                statusEl.textContent = 'Searching for matching Wikidata properties...';
                statusEl.style.padding = '10px';
                statusEl.style.marginTop = '10px';
                statusEl.style.backgroundColor = '#f8f9fa';
                statusEl.style.borderRadius = '4px';
                statusEl.style.textAlign = 'center';
                
                const container = document.getElementById('selected-wikidata-properties');
                container.appendChild(statusEl);
                
                // Process the URIs to be used one by one in separate queries
                // This approach is more reliable as it handles each URI individually
                const processedUris = new Set(); // Track which URIs we've already processed
                const allPromises = [];
                
                uris.forEach(uri => {
                    // Create both HTTP and HTTPS variants
                    const httpVariant = uri.replace(/^https:/, 'http:');
                    const httpsVariant = uri.replace(/^http:/, 'https:');
                    
                    // Create a query that tries both variants
                    const query = `
                        SELECT DISTINCT ?property ?propertyLabel ?propertyDescription ?mappingPredicate ?mappingPredicateLabel ?uri
                        WHERE {
                          VALUES ?uri { <${uri}> <${httpVariant}> <${httpsVariant}> }
                          
                          ?property ?mappingPredicate ?uri .
                          
                          # Filter for mapping predicates commonly used for equivalence
                          VALUES ?mappingPredicate {
                            wdt:P1628    # equivalent property
                            wdt:P2236    # external subproperty
                            wdt:P2235    # external superproperty
                            wdt:P2888    # exact match
                            wdt:P1709    # equivalent class
                          }
                          
                          # Ensure this is a property
                          ?property wdt:P31/wdt:P279* wd:Q18616576 .
                          
                          SERVICE wikibase:label { 
                            bd:serviceParam wikibase:language "en" . 
                          }
                        }
                        ORDER BY ?propertyLabel
                    `;
                    
                    // Create a promise for each query
                    const promise = fetchWikidataQuery(query, uri);
                    allPromises.push(promise);
                });
                
                // Also try matching by name
                const nameQueries = [];
                uris.forEach(uri => {
                    const localName = uri.split(/\/|#/).pop().toLowerCase();
                    if (localName && localName.length > 3) { // Only use names with at least 4 chars
                        const nameQuery = `
                            SELECT DISTINCT ?property ?propertyLabel ?propertyDescription
                            WHERE {
                              ?property wdt:P31 wd:Q18616576 .
                              ?property rdfs:label ?label .
                              FILTER(LANG(?label) = "en")
                              FILTER(LCASE(?label) = "${localName}")
                              
                              SERVICE wikibase:label { 
                                bd:serviceParam wikibase:language "en" . 
                              }
                            }
                            ORDER BY ?propertyLabel
                            LIMIT 5
                        `;
                        const namePromise = fetchWikidataQuery(nameQuery, uri, true);
                        allPromises.push(namePromise);
                    }
                });
                
                // Function to fetch a single query
                function fetchWikidataQuery(query, sourceUri, isNameMatch = false) {
                    const url = `https://query.wikidata.org/sparql?query=${encodeURIComponent(query)}&format=json`;
                    
                    return fetch(url, {
                        headers: {
                            'Accept': 'application/sparql-results+json'
                        }
                    })
                    .then(response => response.json())
                    .then(data => {
                        return {
                            uri: sourceUri,
                            results: data.results ? data.results.bindings : [],
                            isNameMatch: isNameMatch
                        };
                    })
                    .catch(error => {
                        console.error(`Error fetching Wikidata data for ${sourceUri}:`, error);
                        return {
                            uri: sourceUri,
                            results: [],
                            error: error.message
                        };
                    });
                }
                
                // Process all promises from individual queries
                Promise.all(allPromises)
                .then(results => {
                    statusEl.remove();
                    
                    // Prepare collections for results
                    const addedProperties = new Set();
                    const foundMappings = {};
                    let totalMatches = 0;
                    
                    // Process all results
                    results.forEach(queryResult => {
                        if (queryResult.results && queryResult.results.length > 0) {
                            // Track which Omeka property this result is for
                            const omekaUri = queryResult.uri;
                            const omekaProperty = properties.find(p => p.uri === omekaUri);
                            
                            queryResult.results.forEach(result => {
                                const propertyId = result.property.value.split('/').pop();
                                
                                // Skip if already added
                                if (addedProperties.has(propertyId)) {
                                    return;
                                }
                                
                                const propertyLabel = result.propertyLabel ? result.propertyLabel.value : propertyId;
                                const propertyDescription = result.propertyDescription ? result.propertyDescription.value : '';
                                const propertyUri = result.property.value;
                                
                                // Add to selected properties
                                addSelectedWikidataProperty(propertyId, propertyLabel, propertyUri, propertyDescription);
                                addedProperties.add(propertyId);
                                totalMatches++;
                                
                                // If we have a direct match and an Omeka property, create a mapping
                                if (omekaProperty && !queryResult.isNameMatch) {
                                    // Include mapping predicate info if available
                                    let mappingInfo = '';
                                    if (result.mappingPredicate && result.mappingPredicateLabel) {
                                        const predicate = result.mappingPredicate.value.split('/').pop();
                                        const predicateLabel = result.mappingPredicateLabel.value;
                                        mappingInfo = `${predicateLabel} (${predicate})`;
                                    }
                                    
                                    // Create the mapping
                                    const wikidataProperty = {
                                        id: propertyId,
                                        label: propertyLabel,
                                        uri: propertyUri,
                                        description: propertyDescription,
                                        matchReason: mappingInfo || 'Direct match'
                                    };
                                    
                                    foundMappings[omekaProperty.property] = wikidataProperty;
                                }
                            });
                        }
                    });
                    
                    // Apply all found mappings
                    Object.entries(foundMappings).forEach(([omekaKey, wikidataProperty]) => {
                        mappingData[omekaKey] = wikidataProperty;
                    });
                    
                    // Update the mapping results after all properties are added
                    updateMappingResults();
                    
                    // Show messages based on result
                    if (totalMatches === 0) {
                        const noResultsEl = document.createElement('div');
                        noResultsEl.textContent = 'No matching Wikidata properties found automatically.';
                        noResultsEl.style.padding = '10px';
                        noResultsEl.style.color = '#666';
                        noResultsEl.style.fontStyle = 'italic';
                        noResultsEl.style.textAlign = 'center';
                        container.appendChild(noResultsEl);
                        
                        // Auto-remove this message after 5 seconds
                        setTimeout(() => {
                            noResultsEl.remove();
                        }, 5000);
                    } else {
                        // Show success message
                        const mappingsCount = Object.keys(foundMappings).length;
                        const successEl = document.createElement('div');
                        successEl.textContent = `Added ${totalMatches} Wikidata properties and created ${mappingsCount} automatic mappings.`;
                        successEl.style.padding = '10px';
                        successEl.style.backgroundColor = '#d4edda';
                        successEl.style.color = '#155724';
                        successEl.style.borderRadius = '4px';
                        successEl.style.marginTop = '10px';
                        successEl.style.textAlign = 'center';
                        container.appendChild(successEl);
                        
                        // Auto-remove success message after 5 seconds
                        setTimeout(() => {
                            successEl.remove();
                        }, 5000);
                    }
                })
                .catch(error => {
                    console.error('Error processing Wikidata queries:', error);
                    statusEl.textContent = 'Error finding matching properties: ' + error.message;
                    statusEl.style.backgroundColor = '#f8d7da';
                    statusEl.style.color = '#721c24';
                    
                    // Auto-remove error message after 5 seconds
                    setTimeout(() => {
                        statusEl.remove();
                    }, 5000);
                });
            }

            // Render the properties list
            function renderProperties(properties) {
                propertiesContainer.innerHTML = '';
                
                // Add info about total properties
                const infoHeader = document.createElement('div');
                infoHeader.className = 'properties-info';
                infoHeader.innerHTML = `
                    <p>Totaal aantal eigenschappen: <strong>${properties.length}</strong></p>
                    <p>Klik op een eigenschap om details te bekijken.</p>
                `;
                infoHeader.style.marginBottom = '15px';
                infoHeader.style.padding = '10px';
                infoHeader.style.backgroundColor = '#f0f7ff';
                infoHeader.style.borderRadius = '5px';
                propertiesContainer.appendChild(infoHeader);
                
                properties.forEach(property => {
                    const card = document.createElement('div');
                    card.className = 'property-card';
                    
                    const header = document.createElement('div');
                    header.className = 'property-header';
                    
                    const nameContainer = document.createElement('div');
                    nameContainer.style.display = 'flex';
                    nameContainer.style.alignItems = 'center';
                    
                    const name = document.createElement('h3');
                    name.textContent = property.property;
                    nameContainer.appendChild(name);
                    
                    if (property.prefix) {
                        const prefixBadge = document.createElement('span');
                        prefixBadge.className = 'prefix-badge';
                        prefixBadge.textContent = property.prefix;
                        nameContainer.appendChild(prefixBadge);
                    }
                    
                    // Add sample count if available
                    if (property.sampleValues && property.sampleValues.length > 0) {
                        const countBadge = document.createElement('span');
                        countBadge.className = 'property-count';
                        countBadge.textContent = `${property.sampleValues.length} voorbeelden`;
                        nameContainer.appendChild(countBadge);
                    }
                    
                    header.appendChild(nameContainer);
                    
                    const toggleBtn = document.createElement('span');
                    toggleBtn.textContent = '▼';
                    toggleBtn.style.cursor = 'pointer';
                    header.appendChild(toggleBtn);
                    
                    const content = document.createElement('div');
                    content.className = 'property-content';
                    
                    if (property.uri) {
                        const uriContainer = document.createElement('div');
                        uriContainer.style.marginBottom = '15px';
                        
                        const uriLabel = document.createElement('p');
                        uriLabel.innerHTML = '<strong>Linked Open Data URI:</strong>';
                        uriLabel.style.marginBottom = '5px';
                        uriContainer.appendChild(uriLabel);
                        
                        const uriLink = document.createElement('a');
                        uriLink.href = property.uri;
                        uriLink.target = '_blank';
                        uriLink.className = 'uri-link';
                        uriLink.textContent = property.uri;
                        uriContainer.appendChild(uriLink);
                        
                        content.appendChild(uriContainer);
                    }
                    
                    const info = document.createElement('div');
                    info.style.backgroundColor = '#f8f9fa';
                    info.style.padding = '10px';
                    info.style.borderRadius = '5px';
                    info.style.marginBottom = '15px';
                    info.innerHTML = `
                        <h4 style="margin-top: 0;">Technische Informatie</h4>
                        <p><strong>Lokale Naam:</strong> ${property.localName}</p>
                        ${property.namespace ? `<p><strong>Namespace:</strong> ${property.namespace}</p>` : ''}
                        ${property.prefix ? `<p><strong>Prefix:</strong> ${property.prefix}</p>` : ''}
                    `;
                    content.appendChild(info);
                    
                    if (property.sampleValues && property.sampleValues.length > 0) {
                        const samplesSection = document.createElement('div');
                        samplesSection.className = 'sample-values';
                        
                        const samplesTitle = document.createElement('h4');
                        samplesTitle.textContent = 'Voorbeeldwaarden:';
                        samplesSection.appendChild(samplesTitle);
                        
                        const samplesInfo = document.createElement('p');
                        samplesInfo.textContent = 'Hieronder zie je voorbeelden van waarden voor deze eigenschap uit de Omeka S-collectie:';
                        samplesInfo.style.marginBottom = '15px';
                        samplesSection.appendChild(samplesInfo);
                        
                        property.sampleValues.forEach((sample, index) => {
                            const sampleDiv = document.createElement('div');
                            sampleDiv.className = 'sample-value';
                            
                            const sampleHeader = document.createElement('div');
                            sampleHeader.innerHTML = `<strong>Voorbeeld ${index + 1}</strong> (${sample.type}${sample.isArray ? ', array' : ''})`;
                            sampleHeader.style.marginBottom = '5px';
                            sampleDiv.appendChild(sampleHeader);
                            
                            const sampleContent = document.createElement('div');
                            sampleContent.className = 'json-view';
                            sampleContent.textContent = JSON.stringify(sample.rawValue, null, 2);
                            sampleDiv.appendChild(sampleContent);
                            
                            samplesSection.appendChild(sampleDiv);
                        });
                        
                        content.appendChild(samplesSection);
                    }
                    
                    card.appendChild(header);
                    card.appendChild(content);
                    propertiesContainer.appendChild(card);
                    
                    // Toggle content visibility
                    header.addEventListener('click', function() {
                        content.classList.toggle('active');
                        toggleBtn.textContent = content.classList.contains('active') ? '▲' : '▼';
                    });
                });
            }

            // Filter properties based on search input
            propertyFilter.addEventListener('input', function() {
                const filterText = this.value.toLowerCase();
                const propertyCards = propertiesContainer.querySelectorAll('.property-card');
                
                propertyCards.forEach(card => {
                    const propertyName = card.querySelector('h3').textContent.toLowerCase();
                    const prefix = card.querySelector('.prefix-badge')?.textContent.toLowerCase() || '';
                    const uri = card.querySelector('.uri-link')?.textContent.toLowerCase() || '';
                    
                    if (propertyName.includes(filterText) || prefix.includes(filterText) || uri.includes(filterText)) {
                        card.style.display = 'block';
                    } else {
                        card.style.display = 'none';
                    }
                });
            });

            // Tab switching functionality
            tabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    // Remove active class from all tabs
                    tabs.forEach(t => t.classList.remove('active'));
                    
                    // Add active class to clicked tab
                    this.classList.add('active');
                    
                    // Hide all tab contents
                    tabContents.forEach(content => content.classList.remove('active'));
                    
                    // Show the corresponding tab content
                    const tabId = this.getAttribute('data-tab');
                    document.getElementById(tabId).classList.add('active');
                });
            });

            // Render Omeka S properties for mapping
            function renderOmekaProperties(properties) {
                omekaPropertiesContainer.innerHTML = '';
                
                properties.forEach(property => {
                    if (property.uri) {  // Only include properties with URIs
                        const item = document.createElement('div');
                        item.className = 'mapping-item';
                        item.setAttribute('draggable', 'true');
                        item.setAttribute('data-property', property.property);
                        item.setAttribute('data-uri', property.uri);
                        
                        const itemContent = document.createElement('div');
                        itemContent.className = 'mapping-item-content';
                        
                        const itemName = document.createElement('div');
                        itemName.textContent = property.property;
                        itemContent.appendChild(itemName);
                        
                        const itemUri = document.createElement('div');
                        itemUri.className = 'mapping-item-uri';
                        itemUri.textContent = property.uri;
                        itemContent.appendChild(itemUri);
                        
                        item.appendChild(itemContent);
                        omekaPropertiesContainer.appendChild(item);
                        
                        // Add drag functionality
                        item.addEventListener('dragstart', handleDragStart);
                    }
                });
            }

            // Filter Omeka properties based on search input
            omekaPropertyFilter.addEventListener('input', function() {
                const filterText = this.value.toLowerCase();
                const propertyItems = omekaPropertiesContainer.querySelectorAll('.mapping-item');
                
                propertyItems.forEach(item => {
                    const propertyName = item.getAttribute('data-property').toLowerCase();
                    const uri = item.getAttribute('data-uri').toLowerCase();
                    
                    if (propertyName.includes(filterText) || uri.includes(filterText)) {
                        item.style.display = 'flex';
                    } else {
                        item.style.display = 'none';
                    }
                });
            });

            // Search Wikidata properties with debounce
            let searchTimeout = null;
            let wikidataCache = {};  // Cache for wikidata search results
            
            wikidataSearch.addEventListener('input', function() {
                const searchTerm = this.value.trim();
                
                // Clear previous timeout
                if (searchTimeout) {
                    clearTimeout(searchTimeout);
                }
                
                // Clear results if search term is empty
                if (!searchTerm) {
                    wikidataResults.innerHTML = '';
                    wikidataResults.classList.remove('active');
                    wikidataSearchStatus.textContent = '';
                    return;
                }
                
                // Show searching status
                wikidataSearchStatus.textContent = 'Searching...';
                
                // Set a timeout to debounce the search
                searchTimeout = setTimeout(() => {
                    // Check cache first
                    if (wikidataCache[searchTerm]) {
                        displayWikidataResults(wikidataCache[searchTerm]);
                        return;
                    }
                    
                    performWikidataSearch(searchTerm);
                }, 200);
            });
            
            // Hide dropdown when clicking outside
            document.addEventListener('click', function(e) {
                if (!wikidataSearch.contains(e.target) && !wikidataResults.contains(e.target)) {
                    wikidataResults.classList.remove('active');
                }
            });
            
            // Show dropdown when focusing on search input
            wikidataSearch.addEventListener('focus', function() {
                if (wikidataResults.childElementCount > 0) {
                    wikidataResults.classList.add('active');
                }
            });

            function performWikidataSearch(searchTerm) {
                // Use Wikidata API for faster and more accurate results
                const url = `https://www.wikidata.org/w/api.php?action=wbsearchentities&search=${encodeURIComponent(searchTerm)}&format=json&language=en&type=property&origin=*&limit=20`;
                
                fetch(url)
                    .then(response => response.json())
                    .then(data => {
                        // Store in cache
                        wikidataCache[searchTerm] = data.search;
                        displayWikidataResults(data.search);
                    })
                    .catch(error => {
                        wikidataSearchStatus.textContent = '';
                        wikidataResults.innerHTML = `<div class="wikidata-result-item">Error searching Wikidata: ${error.message}</div>`;
                        wikidataResults.classList.add('active');
                    });
            }
            
            // Entity Schema search and property extraction
            let entitySchemaTimeout = null;
            let entitySchemaCache = {};
            
            // Set up entity schema search functionality
            entitySchemaSearch.addEventListener('input', function() {
                const searchTerm = this.value.trim().toUpperCase();
                
                // Clear previous timeout
                if (entitySchemaTimeout) {
                    clearTimeout(entitySchemaTimeout);
                }
                
                // Clear results if search term is empty
                if (!searchTerm) {
                    entitySchemaResults.innerHTML = '';
                    entitySchemaResults.classList.remove('active');
                    entitySchemaStatus.textContent = '';
                    return;
                }
                
                // Show searching status
                entitySchemaStatus.textContent = 'Zoeken...';
                
                // Set a timeout to debounce the search
                entitySchemaTimeout = setTimeout(() => {
                    // Validate that the search term looks like an entity schema ID (E followed by numbers)
                    if (!/^E\d+$/.test(searchTerm)) {
                        performEntitySchemaLabelSearch(searchTerm);
                        return;
                    }
                    
                    // Check cache first
                    if (entitySchemaCache[searchTerm]) {
                        displayEntitySchemaResults(entitySchemaCache[searchTerm]);
                        return;
                    }
                    
                    // Perform the search
                    performEntitySchemaSearch(searchTerm);
                }, 300);
            });
            
            // Hide dropdown when clicking outside
            document.addEventListener('click', function(e) {
                if (!entitySchemaSearch.contains(e.target) && !entitySchemaResults.contains(e.target)) {
                    entitySchemaResults.classList.remove('active');
                }
            });
            
            // Show dropdown when focusing on search input
            entitySchemaSearch.addEventListener('focus', function() {
                if (entitySchemaResults.childElementCount > 0) {
                    entitySchemaResults.classList.add('active');
                }
            });
            
            function performEntitySchemaSearch(schemaId) {
                const url = `https://www.wikidata.org/wiki/Special:EntitySchemaText/${schemaId}`;
                
                // Set loading status
                entitySchemaStatus.textContent = 'Laden...';
                
                fetch(url)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Schema niet gevonden (HTTP ${response.status})`);
                        }
                        return response.text();
                    })
                    .then(shexCode => {
                        const schemaInfo = { id: schemaId, shexCode };
                        
                        // Get the schema label (title)
                        const titleUrl = `https://www.wikidata.org/w/api.php?action=wbgetentities&ids=${schemaId}&format=json&origin=*`;
                        return fetch(titleUrl)
                            .then(response => response.json())
                            .then(data => {
                                if (data.entities && data.entities[schemaId]) {
                                    schemaInfo.label = data.entities[schemaId].labels.en.value;
                                } else {
                                    schemaInfo.label = schemaId;
                                }
                                return schemaInfo;
                            })
                            .catch(() => {
                                // If we can't get the label, just use the ID
                                schemaInfo.label = schemaId;
                                return schemaInfo;
                            });
                    })
                    .then(schemaInfo => {
                        // Cache the result
                        entitySchemaCache[schemaId] = [schemaInfo];
                        displayEntitySchemaResults([schemaInfo]);
                    })
                    .catch(error => {
                        entitySchemaStatus.textContent = '';
                        entitySchemaResults.innerHTML = `<div class="wikidata-result-item">Fout bij laden schema: ${error.message}</div>`;
                        entitySchemaResults.classList.add('active');
                    });
            }
            
            function performEntitySchemaLabelSearch(searchTerm) {
                // Search for entity schemas by name/label
                const url = `https://www.wikidata.org/w/api.php?action=wbsearchentities&search=${encodeURIComponent(searchTerm)}&format=json&language=en&type=item&origin=*&limit=10`;
                
                fetch(url)
                    .then(response => response.json())
                    .then(data => {
                        // Filter results to only include entity schemas (which have IDs starting with E)
                        const schemas = data.search.filter(item => item.id.startsWith('E'));
                        
                        if (schemas.length === 0) {
                            entitySchemaResults.innerHTML = '<div class="wikidata-result-item">Geen entity schemas gevonden met deze naam.</div>';
                            entitySchemaResults.classList.add('active');
                            entitySchemaStatus.textContent = '';
                            return;
                        }
                        
                        // Format results
                        const schemaResults = schemas.map(schema => ({
                            id: schema.id,
                            label: schema.label || schema.id,
                            description: schema.description || '',
                        }));
                        
                        // Cache and display results
                        entitySchemaCache[searchTerm] = schemaResults;
                        displayEntitySchemaResults(schemaResults);
                    })
                    .catch(error => {
                        entitySchemaStatus.textContent = '';
                        entitySchemaResults.innerHTML = `<div class="wikidata-result-item">Fout bij zoeken: ${error.message}</div>`;
                        entitySchemaResults.classList.add('active');
                    });
            }
            
            function displayEntitySchemaResults(results) {
                entitySchemaStatus.textContent = '';
                
                if (!results || results.length === 0) {
                    entitySchemaResults.innerHTML = '<div class="wikidata-result-item">Geen resultaten gevonden.</div>';
                    entitySchemaResults.classList.add('active');
                    return;
                }
                
                entitySchemaResults.innerHTML = '';
                
                results.forEach(result => {
                    const schemaId = result.id;
                    const schemaLabel = result.label || schemaId;
                    const schemaDescription = result.description || '';
                    
                    const item = document.createElement('div');
                    item.className = 'wikidata-result-item';
                    item.setAttribute('data-schema-id', schemaId);
                    item.setAttribute('data-schema-label', schemaLabel);
                    
                    const itemName = document.createElement('div');
                    itemName.innerHTML = `<span class="wikidata-property-id">${schemaId}</span>${schemaLabel}`;
                    item.appendChild(itemName);
                    
                    if (schemaDescription) {
                        const itemDesc = document.createElement('div');
                        itemDesc.className = 'wikidata-property-description';
                        itemDesc.textContent = schemaDescription;
                        item.appendChild(itemDesc);
                    }
                    
                    // Make item clickable to select schema
                    item.addEventListener('click', function() {
                        selectEntitySchema(schemaId, schemaLabel);
                        
                        // Hide dropdown
                        entitySchemaResults.classList.remove('active');
                        
                        // Update input field
                        entitySchemaSearch.value = schemaId;
                    });
                    
                    entitySchemaResults.appendChild(item);
                });
                
                entitySchemaResults.classList.add('active');
            }
            
            function selectEntitySchema(schemaId, schemaLabel) {
                currentSchemaId = schemaId;
                currentSchemaName.textContent = `${schemaLabel} (${schemaId})`;
                
                // Also update the schema properties title
                const schemaPropertiesTitle = document.getElementById('schema-properties-title');
                if (schemaPropertiesTitle) {
                    schemaPropertiesTitle.textContent = schemaId;
                }
            }
            
            // Parse ShEx code to extract Wikidata properties
            function parseShExProperties(shexCode) {
                // Regular expression to find wdt:P... patterns in the ShEx code
                const propertyRegex = /wdt:P(\d+)/g;
                const matches = [...shexCode.matchAll(propertyRegex)];
                
                // Extract unique property IDs
                const propertyIds = new Set();
                matches.forEach(match => {
                    propertyIds.add(match[1]);
                });
                
                return Array.from(propertyIds).map(id => `P${id}`);
            }
            
            // Load schema properties button event
            loadSchemaPropertiesBtn.addEventListener('click', function() {
                if (!currentSchemaId) {
                    alert('Selecteer eerst een Entity Schema.');
                    return;
                }
                
                // Check if we already have the schema in cache
                if (entitySchemaCache[currentSchemaId] && entitySchemaCache[currentSchemaId][0].shexCode) {
                    const shexCode = entitySchemaCache[currentSchemaId][0].shexCode;
                    loadPropertiesFromShEx(shexCode);
                    return;
                }
                
                // Otherwise, fetch it
                const url = `https://www.wikidata.org/wiki/Special:EntitySchemaText/${currentSchemaId}`;
                
                // Show loading status
                this.textContent = 'Laden...';
                this.disabled = true;
                
                fetch(url)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Schema niet gevonden (HTTP ${response.status})`);
                        }
                        return response.text();
                    })
                    .then(shexCode => {
                        // Store in cache
                        if (!entitySchemaCache[currentSchemaId]) {
                            entitySchemaCache[currentSchemaId] = [{ id: currentSchemaId }];
                        }
                        entitySchemaCache[currentSchemaId][0].shexCode = shexCode;
                        
                        // Load properties
                        loadPropertiesFromShEx(shexCode);
                    })
                    .catch(error => {
                        alert(`Fout bij laden van schema: ${error.message}`);
                    })
                    .finally(() => {
                        this.textContent = 'Laad eigenschappen van schema';
                        this.disabled = false;
                    });
            });
            
            function loadPropertiesFromShEx(shexCode) {
                // Parse properties from ShEx
                const propertyIds = parseShExProperties(shexCode);
                
                if (propertyIds.length === 0) {
                    alert('Geen eigenschappen gevonden in het schema.');
                    return;
                }
                
                // Show loading message
                const statusEl = document.createElement('div');
                statusEl.textContent = `Laden van ${propertyIds.length} eigenschappen...`;
                statusEl.style.padding = '10px';
                statusEl.style.marginTop = '10px';
                statusEl.style.backgroundColor = '#f8f9fa';
                statusEl.style.borderRadius = '4px';
                statusEl.style.textAlign = 'center';
                
                // Use the schema properties container instead of the regular container
                const container = document.getElementById('schema-properties');
                
                // Clear existing schema properties except for the header and info text
                const elementsToKeep = ['h4', '.schema-properties-info']; 
                const children = Array.from(container.children);
                
                children.forEach(child => {
                    const shouldKeep = elementsToKeep.some(selector => 
                        child.matches(selector) || child.querySelector(selector)
                    );
                    
                    if (!shouldKeep) {
                        child.remove();
                    }
                });
                
                container.appendChild(statusEl);
                
                // Create an array of promises for fetching property details
                const propertyPromises = propertyIds.map(propertyId => {
                    return fetchPropertyDetails(propertyId);
                });
                
                // Process all property fetches
                Promise.all(propertyPromises)
                    .then(properties => {
                        // Filter out any null results
                        const validProperties = properties.filter(prop => prop !== null);
                        
                        // Remove the status element
                        statusEl.remove();
                        
                        if (validProperties.length === 0) {
                            alert('Geen eigenschappen konden worden geladen.');
                            return;
                        }
                        
                        // Add a special schema source label
                        const sourceLabel = document.createElement('div');
                        sourceLabel.className = 'schema-source-label';
                        sourceLabel.innerHTML = `<strong>${validProperties.length} eigenschappen</strong> geladen van schema ${currentSchemaId}`;
                        sourceLabel.style.marginBottom = '15px';
                        sourceLabel.style.fontSize = '0.9em';
                        sourceLabel.style.color = '#8B6914';
                        container.appendChild(sourceLabel);
                        
                        // Add all properties to the schema properties container with a special class
                        validProperties.forEach(property => {
                            addPropertyToContainer(
                                container,
                                property.id,
                                property.label,
                                property.uri,
                                property.description,
                                true // is schema property
                            );
                        });
                        
                        // Show success message
                        const successEl = document.createElement('div');
                        successEl.textContent = `${validProperties.length} eigenschappen geladen van Entity Schema ${currentSchemaId}.`;
                        successEl.style.padding = '10px';
                        successEl.style.backgroundColor = '#d4edda';
                        successEl.style.color = '#155724';
                        successEl.style.borderRadius = '4px';
                        successEl.style.marginTop = '10px';
                        successEl.style.textAlign = 'center';
                        
                        // Add success message after the property items
                        container.appendChild(successEl);
                        
                        // Auto-remove success message after 5 seconds
                        setTimeout(() => {
                            successEl.remove();
                        }, 5000);
                    })
                    .catch(error => {
                        statusEl.remove();
                        alert(`Fout bij laden van eigenschappen: ${error.message}`);
                    });
            }
            
            // Function to add a property to any container (either schema or selected properties)
            function addPropertyToContainer(container, id, label, uri, description, isSchemaProperty = false) {
                // Check if this property is already in the container
                if (container.querySelector(`[data-property-id="${id}"]`)) {
                    return;
                }
                
                // Create the property item
                const item = document.createElement('div');
                item.className = 'mapping-item';
                if (isSchemaProperty) {
                    item.classList.add('schema-property-item');
                    item.style.borderLeft = '3px solid #ffd700';
                }
                
                item.setAttribute('data-property-id', id);
                item.setAttribute('data-property-label', label);
                item.setAttribute('data-property-uri', uri);
                
                const itemContent = document.createElement('div');
                itemContent.className = 'mapping-item-content';
                
                const itemName = document.createElement('div');
                itemName.innerHTML = `<strong>${id}</strong>: ${label}`;
                itemContent.appendChild(itemName);
                
                if (description) {
                    const itemDesc = document.createElement('div');
                    itemDesc.className = 'mapping-item-uri';
                    itemDesc.textContent = description;
                    itemContent.appendChild(itemDesc);
                }
                
                // Add remove button
                const removeBtn = document.createElement('button');
                removeBtn.textContent = '×';
                removeBtn.style.marginLeft = '10px';
                removeBtn.style.padding = '0 5px';
                removeBtn.style.background = 'none';
                removeBtn.style.border = 'none';
                removeBtn.style.fontSize = '16px';
                removeBtn.style.cursor = 'pointer';
                removeBtn.title = 'Verwijder uit selectie';
                
                removeBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    item.remove();
                });
                
                item.appendChild(itemContent);
                item.appendChild(removeBtn);
                container.appendChild(item);
                
                // Add drag functionality
                item.setAttribute('draggable', 'true');
                item.addEventListener('dragstart', function(e) {
                    const wikidataProperty = {
                        id: id,
                        label: label,
                        uri: uri,
                        description: description
                    };
                    e.dataTransfer.setData('application/json-wikidata', JSON.stringify(wikidataProperty));
                });
                
                // Add drop target functionality for Omeka properties
                item.addEventListener('dragover', allowDrop);
                item.addEventListener('drop', handleDrop);
            }
            
            // Fetch details for a single property
            function fetchPropertyDetails(propertyId) {
                const url = `https://www.wikidata.org/w/api.php?action=wbgetentities&ids=${propertyId}&format=json&origin=*`;
                
                return fetch(url)
                    .then(response => response.json())
                    .then(data => {
                        if (data.entities && data.entities[propertyId]) {
                            const entity = data.entities[propertyId];
                            return {
                                id: propertyId,
                                label: entity.labels && entity.labels.en ? entity.labels.en.value : propertyId,
                                description: entity.descriptions && entity.descriptions.en ? entity.descriptions.en.value : '',
                                uri: `http://www.wikidata.org/entity/${propertyId}`
                            };
                        }
                        return null;
                    })
                    .catch(error => {
                        console.error(`Error fetching property ${propertyId}:`, error);
                        return null;
                    });
            }

            function displayWikidataResults(results) {
                wikidataSearchStatus.textContent = '';
                
                if (!results || results.length === 0) {
                    wikidataResults.innerHTML = '<div class="wikidata-result-item">No results found.</div>';
                    wikidataResults.classList.add('active');
                    return;
                }
                
                wikidataResults.innerHTML = '';
                
                // Use a Set to track unique property IDs
                const addedProperties = new Set();
                
                results.forEach(result => {
                    const propertyId = result.id;
                    
                    // Skip if this property ID is already added
                    if (addedProperties.has(propertyId)) {
                        return;
                    }
                    
                    addedProperties.add(propertyId);
                    
                    const propertyLabel = result.label || '';
                    const propertyDescription = result.description || '';
                    const propertyUri = `http://www.wikidata.org/entity/${propertyId}`;
                    
                    const item = document.createElement('div');
                    item.className = 'wikidata-result-item';
                    item.setAttribute('data-property-id', propertyId);
                    item.setAttribute('data-property-label', propertyLabel);
                    item.setAttribute('data-property-uri', propertyUri);
                    
                    const itemName = document.createElement('div');
                    itemName.innerHTML = `<span class="wikidata-property-id">${propertyId}</span>${propertyLabel}`;
                    item.appendChild(itemName);
                    
                    if (propertyDescription) {
                        const itemDesc = document.createElement('div');
                        itemDesc.className = 'wikidata-property-description';
                        itemDesc.textContent = propertyDescription;
                        item.appendChild(itemDesc);
                    }
                    
                    // Make items droppable on all views
                    item.setAttribute('draggable', 'true');
                    item.addEventListener('dragstart', function(e) {
                        // Create a Wikidata property object to use in mappings
                        const wikidataProperty = {
                            id: propertyId,
                            label: propertyLabel,
                            uri: propertyUri,
                            description: propertyDescription
                        };
                        e.dataTransfer.setData('application/json-wikidata', JSON.stringify(wikidataProperty));
                    });
                    
                    // Make item clickable to add to mapping area
                    item.addEventListener('click', function() {
                        // Add to wikidata selected properties area
                        addSelectedWikidataProperty(propertyId, propertyLabel, propertyUri, propertyDescription);
                        
                        // Hide dropdown
                        wikidataResults.classList.remove('active');
                        
                        // Clear search field
                        wikidataSearch.value = '';
                    });
                    
                    wikidataResults.appendChild(item);
                });
                
                wikidataResults.classList.add('active');
            }
            
            function addSelectedWikidataProperty(id, label, uri, description) {
                // Get the container for selected Wikidata properties
                let selectedWikidataContainer = document.getElementById('selected-wikidata-properties');
                
                // If container doesn't exist, something went wrong - recreate it
                if (!selectedWikidataContainer) {
                    console.log("Recreating wikidata properties container");
                    selectedWikidataContainer = document.createElement('div');
                    selectedWikidataContainer.id = 'selected-wikidata-properties';
                    selectedWikidataContainer.className = 'droppable-area';
                    selectedWikidataContainer.setAttribute('data-type', 'wikidata');
                    
                    const header = document.createElement('h4');
                    header.textContent = 'Overige geselecteerde eigenschappen';
                    selectedWikidataContainer.appendChild(header);
                    
                    // Add it back to the DOM
                    const container = document.querySelector('.wikidata-properties-container');
                    container.appendChild(selectedWikidataContainer);
                }
                
                // Use our new helper function to add the property to the container
                addPropertyToContainer(selectedWikidataContainer, id, label, uri, description);
            }

            // Drag and drop for mapping
            function handleDragStart(e) {
                const omekaProperty = {
                    name: this.getAttribute('data-property'),
                    uri: this.getAttribute('data-uri')
                };
                e.dataTransfer.setData('application/json', JSON.stringify(omekaProperty));
            }

            function allowDrop(e) {
                e.preventDefault();
                this.style.backgroundColor = '#d6eaf8';
            }

            function handleDrop(e) {
                e.preventDefault();
                this.style.backgroundColor = '';
                
                try {
                    // First try to get Omeka property data
                    let omekaProperty = null;
                    let wikidataProperty = null;
                    
                    try {
                        const omekaData = e.dataTransfer.getData('application/json');
                        if (omekaData) {
                            omekaProperty = JSON.parse(omekaData);
                        }
                    } catch (err) {
                        console.log('No Omeka property data found');
                    }
                    
                    try {
                        const wikidataData = e.dataTransfer.getData('application/json-wikidata');
                        if (wikidataData) {
                            wikidataProperty = JSON.parse(wikidataData);
                        }
                    } catch (err) {
                        console.log('No Wikidata property data found');
                    }
                    
                    // Determine what's been dropped where
                    const dropTarget = this.closest('.droppable-area');
                    const dropTargetType = dropTarget ? dropTarget.getAttribute('data-type') : null;
                    
                    if (omekaProperty && wikidataProperty) {
                        // Both properties available, create mapping
                        mappingData[omekaProperty.name] = wikidataProperty;
                        updateMappingResults();
                    } else if (omekaProperty && dropTargetType === 'wikidata') {
                        // Omeka property dropped on Wikidata area
                        // Find the nearest Wikidata property to create a mapping
                        const closestWikidataItem = findClosestMappingItem(e.clientY, 'selected-wikidata-properties');
                        if (closestWikidataItem) {
                            const wikidataId = closestWikidataItem.getAttribute('data-property-id');
                            const wikidataLabel = closestWikidataItem.getAttribute('data-property-label');
                            const wikidataUri = closestWikidataItem.getAttribute('data-property-uri');
                            
                            const wikidataProperty = {
                                id: wikidataId,
                                label: wikidataLabel,
                                uri: wikidataUri
                            };
                            
                            mappingData[omekaProperty.name] = wikidataProperty;
                            updateMappingResults();
                        }
                    } else if (wikidataProperty && dropTargetType === 'omeka') {
                        // Wikidata property dropped on Omeka area
                        // Find the nearest Omeka property to create a mapping
                        const closestOmekaItem = findClosestMappingItem(e.clientY, 'omeka-properties');
                        if (closestOmekaItem) {
                            const omekaName = closestOmekaItem.getAttribute('data-property');
                            mappingData[omekaName] = wikidataProperty;
                            updateMappingResults();
                        }
                    } else if (this.hasAttribute('data-property-id')) {
                        // Dropped on a Wikidata property
                        const wikidataProperty = {
                            id: this.getAttribute('data-property-id'),
                            label: this.getAttribute('data-property-label'),
                            uri: this.getAttribute('data-property-uri')
                        };
                        
                        if (omekaProperty) {
                            // Add to mapping data
                            mappingData[omekaProperty.name] = wikidataProperty;
                            updateMappingResults();
                        }
                    }
                } catch (error) {
                    console.error('Error processing drop:', error);
                }
            }
            
            function findClosestMappingItem(y, containerId) {
                const container = document.getElementById(containerId);
                const items = container.querySelectorAll('.mapping-item');
                let closest = null;
                let minDistance = Infinity;
                
                items.forEach(item => {
                    const rect = item.getBoundingClientRect();
                    const itemCenter = rect.top + rect.height / 2;
                    const distance = Math.abs(y - itemCenter);
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        closest = item;
                    }
                });
                
                return closest;
            }

            function updateMappingResults() {
                const mappingResults = document.getElementById('mapping-results');
                
                if (Object.keys(mappingData).length === 0) {
                    mappingResults.innerHTML = '<p class="centered">No mappings created yet. Drag Omeka S properties to Wikidata properties to create mappings.</p>';
                    exportMappingBtn.disabled = true;
                    return;
                }
                
                exportMappingBtn.disabled = false;
                
                // Create a table to display mappings
                mappingResults.innerHTML = `
                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Omeka S Property</th>
                                    <th>Omeka S URI</th>
                                    <th>Wikidata Property</th>
                                    <th>Wikidata URI</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody id="mapping-table-body"></tbody>
                        </table>
                    </div>
                `;
                
                const tableBody = document.getElementById('mapping-table-body');
                
                for (const [omekaKey, wikidataValue] of Object.entries(mappingData)) {
                    const row = document.createElement('tr');
                    
                    // Find the full Omeka property data
                    const omekaProperty = propertiesData.properties.find(p => p.property === omekaKey);
                    
                    row.innerHTML = `
                        <td>${omekaKey}</td>
                        <td><a href="${omekaProperty?.uri}" target="_blank">${omekaProperty?.uri || '-'}</a></td>
                        <td>${wikidataValue.id}: ${wikidataValue.label}</td>
                        <td><a href="${wikidataValue.uri}" target="_blank">${wikidataValue.uri}</a></td>
                        <td><button class="button" data-omeka-key="${omekaKey}">Remove</button></td>
                    `;
                    
                    tableBody.appendChild(row);
                }
                
                // Add event listeners to the remove buttons
                const removeButtons = tableBody.querySelectorAll('button[data-omeka-key]');
                removeButtons.forEach(button => {
                    button.addEventListener('click', function() {
                        const omekaKey = this.getAttribute('data-omeka-key');
                        delete mappingData[omekaKey];
                        updateMappingResults();
                    });
                });
            }

            // Export mapping
            exportMappingBtn.addEventListener('click', function() {
                if (Object.keys(mappingData).length === 0) {
                    alert('No mappings to export.');
                    return;
                }
                
                const exportData = {
                    exportDate: new Date().toISOString(),
                    mappings: []
                };
                
                for (const [omekaKey, wikidataValue] of Object.entries(mappingData)) {
                    const omekaProperty = propertiesData.properties.find(p => p.property === omekaKey);
                    
                    exportData.mappings.push({
                        omeka: {
                            property: omekaKey,
                            uri: omekaProperty?.uri,
                            prefix: omekaProperty?.prefix,
                            namespace: omekaProperty?.namespace,
                            localName: omekaProperty?.localName
                        },
                        wikidata: {
                            property: wikidataValue.id,
                            label: wikidataValue.label,
                            uri: wikidataValue.uri
                        }
                    });
                }
                
                // Create a file and download it
                const jsonString = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = 'property-mapping.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });

            // If there's a hash in the URL indicating a file, try to fetch it
            if (window.location.hash) {
                const fileUrl = window.location.hash.substring(1);
                if (fileUrl) {
                    fetch(fileUrl)
                        .then(response => response.json())
                        .then(data => {
                            loadProperties(data);
                        })
                        .catch(error => {
                            console.error('Error loading file from URL:', error);
                        });
                }
            }
            
            // Auto-load the default Entity Schema (E471) information and its properties
            setTimeout(() => {
                // Load the schema info
                performEntitySchemaSearch('E471');
                
                // Also load the properties from this schema automatically
                const url = `https://www.wikidata.org/wiki/Special:EntitySchemaText/E471`;
                
                fetch(url)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Schema niet gevonden (HTTP ${response.status})`);
                        }
                        return response.text();
                    })
                    .then(shexCode => {
                        // Store in cache
                        if (!entitySchemaCache['E471']) {
                            entitySchemaCache['E471'] = [{ id: 'E471', label: 'Individual copy of a book' }];
                        }
                        entitySchemaCache['E471'][0].shexCode = shexCode;
                        
                        // Load the properties automatically
                        loadPropertiesFromShEx(shexCode);
                    })
                    .catch(error => {
                        console.error(`Error loading default schema: ${error.message}`);
                    });
            }, 1000);
        });
    </script>
</body>
</html>