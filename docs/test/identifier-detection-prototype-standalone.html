<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Identifier Detection Prototype</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }

        .container {
            background: white;
            border-radius: 8px;
            padding: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        h1 {
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }

        h2 {
            color: #34495e;
            margin-top: 30px;
        }

        h3 {
            color: #7f8c8d;
            border-left: 4px solid #3498db;
            padding-left: 12px;
        }

        .button {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
        }

        .button:hover {
            background: #2980b9;
        }

        .button--secondary {
            background: #95a5a6;
        }

        .button--secondary:hover {
            background: #7f8c8d;
        }

        .loading {
            display: inline-block;
            padding: 10px;
            background: #e8f4fd;
            border: 1px solid #3498db;
            border-radius: 4px;
            color: #2980b9;
        }

        .results-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .item-card {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 16px;
            background: #fdfdfd;
        }

        .item-title {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .identifier-type {
            margin-bottom: 15px;
        }

        .identifier-type h4 {
            margin: 0 0 8px 0;
            color: #7f8c8d;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .identifier-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .identifier-item {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 8px 12px;
            margin-bottom: 6px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 13px;
        }

        .identifier-item.matched {
            background: #d4edda;
            border-color: #c3e6cb;
            color: #155724;
        }

        .identifier-item.conflict {
            background: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
        }

        .wikidata-match {
            font-size: 12px;
            color: #6c757d;
            margin-top: 4px;
        }

        .wikidata-match a {
            color: #3498db;
            text-decoration: none;
        }

        .wikidata-match a:hover {
            text-decoration: underline;
        }

        .conflict-indicator {
            background: #dc3545;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            margin-left: 8px;
        }

        .stats-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-top: 20px;
        }

        .stat-card {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 16px;
            text-align: center;
        }

        .stat-number {
            font-size: 28px;
            font-weight: bold;
            color: #3498db;
            display: block;
        }

        .stat-label {
            color: #6c757d;
            font-size: 14px;
            margin-top: 4px;
        }

        .error {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
            padding: 12px;
            border-radius: 4px;
            margin: 10px 0;
        }

        .success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 12px;
            border-radius: 4px;
            margin: 10px 0;
        }

        .json-preview {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 12px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
            color: #495057;
        }

        .api-status {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 8px;
        }

        .api-status.success {
            background: #d4edda;
            color: #155724;
        }

        .api-status.error {
            background: #f8d7da;
            color: #721c24;
        }

        .progress-bar {
            width: 100%;
            background-color: #e9ecef;
            border-radius: 4px;
            margin: 10px 0;
        }

        .progress-fill {
            background-color: #3498db;
            height: 8px;
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        @media (max-width: 768px) {
            .results-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç Identifier Detection System Prototype</h1>
        <p>This prototype demonstrates automatic detection and matching of identifiers from Omeka S API responses to Wikidata entities.</p>
        
        <div class="controls">
            <button id="runDetection" class="button">üöÄ Run Identifier Detection</button>
            <button id="showSampleData" class="button button--secondary">üìÑ Show Sample Data</button>
            <button id="testApiCalls" class="button button--secondary">üîß Test API Calls</button>
        </div>

        <div id="loadingIndicator" class="loading" style="display: none;">
            Processing identifiers and querying Wikidata...
            <div class="progress-bar">
                <div id="progressFill" class="progress-fill" style="width: 0%;"></div>
            </div>
        </div>

        <div id="errorContainer" style="display: none;"></div>
    </div>

    <!-- Sample Data Container -->
    <div id="sampleDataContainer" class="container" style="display: none;">
        <h2>üìÑ Sample Omeka S Data</h2>
        <p>Sample data from Maastricht University Digital Collections API:</p>
        <div id="sampleDataContent" class="json-preview"></div>
    </div>

    <!-- API Test Results Container -->
    <div id="apiTestContainer" class="container" style="display: none;">
        <h2>üîß API Test Results</h2>
        <div id="apiTestResults"></div>
    </div>

    <!-- Statistics Container -->
    <div id="statsContainer" class="container" style="display: none;">
        <h2>üìä Detection Statistics</h2>
        <div id="statsContent" class="stats-container"></div>
    </div>

    <!-- Results Container -->
    <div id="resultsContainer" class="container" style="display: none;">
        <h2>üéØ Detection Results</h2>
        <div id="resultsContent" class="results-grid"></div>
    </div>

    <!-- Conflicts Container -->
    <div id="conflictsContainer" class="container" style="display: none;">
        <h2>‚ö†Ô∏è Detected Conflicts</h2>
        <p>The following conflicts were detected where multiple identifiers point to different Wikidata entities:</p>
        <div id="conflictsContent"></div>
    </div>

    <script>
        // Identifier Detection System embedded directly for local file testing
        class IdentifierDetection {
            constructor() {
                this.extractedIdentifiers = {};
                this.wikidataMatches = {};
                this.conflicts = {};
            }

            async processItems(omekaItems) {
                console.log('üîç Starting identifier detection for', omekaItems.length, 'items');

                for (const item of omekaItems) {
                    const itemId = item['o:id'];
                    console.log(`Processing item ${itemId}:`, item['o:title']);

                    this.extractedIdentifiers[itemId] = this.extractAllIdentifiers(item);
                }

                await this.matchWithWikidata();
                this.detectConflicts();

                return {
                    extractedIdentifiers: this.extractedIdentifiers,
                    wikidataMatches: this.wikidataMatches,
                    conflicts: this.conflicts
                };
            }

            extractAllIdentifiers(item) {
                const identifiers = {
                    itemLevel: {
                        ark: this.extractARK(item),
                        oclc: this.extractOCLC(item)
                    },
                    valueLevel: {
                        viaf: this.extractVIAF(item),
                        geonames: this.extractGeoNames(item),
                        iso639: this.extractLanguageCodes(item),
                        wikidataQids: this.extractWikidataQIDs(item)
                    }
                };

                console.log(`Extracted identifiers for item ${item['o:id']}:`, identifiers);
                return identifiers;
            }

            extractARK(item) {
                const arkPattern = /ark:\/\d+\/.+/;
                const identifiers = [];

                const dctermsIdentifier = item['dcterms:identifier'];
                if (Array.isArray(dctermsIdentifier)) {
                    for (const identifier of dctermsIdentifier) {
                        if (identifier.type === 'literal' && identifier['@value']) {
                            const match = identifier['@value'].match(arkPattern);
                            if (match) {
                                identifiers.push({
                                    value: match[0],
                                    source: 'dcterms:identifier'
                                });
                            }
                        }
                    }
                }

                return identifiers;
            }

            extractOCLC(item) {
                const oclcPattern = /oclc\/(\d+)/;
                const identifiers = [];

                const sameAs = item['schema:sameAs'];
                if (Array.isArray(sameAs)) {
                    for (const reference of sameAs) {
                        if (reference.type === 'uri' && reference['@id']) {
                            const match = reference['@id'].match(oclcPattern);
                            if (match) {
                                identifiers.push({
                                    value: match[1],
                                    source: 'schema:sameAs',
                                    url: reference['@id']
                                });
                            }
                        }
                    }
                }

                return identifiers;
            }

            extractVIAF(item) {
                const viafPattern = /viaf\.org\/viaf\/(\d+)/;
                const identifiers = [];

                const fieldsToCheck = ['schema:publisher', 'schema:author', 'schema:creator'];

                for (const fieldName of fieldsToCheck) {
                    const field = item[fieldName];
                    if (Array.isArray(field)) {
                        for (const value of field) {
                            if (value.type && value.type.includes('viaf') && value['@id']) {
                                const match = value['@id'].match(viafPattern);
                                if (match) {
                                    identifiers.push({
                                        value: match[1],
                                        source: fieldName,
                                        url: value['@id'],
                                        label: value['o:label'] || null
                                    });
                                }
                            }
                        }
                    }
                }

                return identifiers;
            }

            extractGeoNames(item) {
                const geonamesPattern = /geonames\.org\/(\d+)/;
                const identifiers = [];

                const fieldsToCheck = ['schema:locationCreated', 'schema:itemLocation'];

                for (const fieldName of fieldsToCheck) {
                    const field = item[fieldName];
                    if (Array.isArray(field)) {
                        for (const value of field) {
                            if (value.type && value.type.includes('geonames') && value['@id']) {
                                const match = value['@id'].match(geonamesPattern);
                                if (match) {
                                    identifiers.push({
                                        value: match[1],
                                        source: fieldName,
                                        url: value['@id'],
                                        label: value['o:label'] || null
                                    });
                                }
                            }
                        }
                    }
                }

                return identifiers;
            }

            extractLanguageCodes(item) {
                const iso639Pattern = /iso639-([13])\/([a-z]{2,3})/;
                const identifiers = [];

                const inLanguage = item['schema:inLanguage'];
                if (Array.isArray(inLanguage)) {
                    for (const language of inLanguage) {
                        if (language.type && language.type.includes('iso6391') && language['@id']) {
                            const match = language['@id'].match(iso639Pattern);
                            if (match) {
                                identifiers.push({
                                    value: match[2],
                                    type: `ISO 639-${match[1]}`,
                                    source: 'schema:inLanguage',
                                    url: language['@id'],
                                    label: language['o:label'] || null
                                });
                            }
                        }
                    }
                }

                return identifiers;
            }

            extractWikidataQIDs(item) {
                const wikidataPattern = /wikidata\.org\/(?:wiki\/|entity\/)([QP]\d+)/;
                const identifiers = [];

                const searchObject = (obj, path = '') => {
                    if (Array.isArray(obj)) {
                        obj.forEach((item, index) => {
                            searchObject(item, `${path}[${index}]`);
                        });
                    } else if (obj && typeof obj === 'object') {
                        for (const [key, value] of Object.entries(obj)) {
                            if (key === '@id' && typeof value === 'string') {
                                const match = value.match(wikidataPattern);
                                if (match) {
                                    identifiers.push({
                                        value: match[1],
                                        source: path || key,
                                        url: value,
                                        label: obj['o:label'] || null
                                    });
                                }
                            } else {
                                searchObject(value, path ? `${path}.${key}` : key);
                            }
                        }
                    }
                };

                searchObject(item);
                return identifiers;
            }

            async matchWithWikidata() {
                console.log('üîÑ Querying Wikidata for identifier matches...');

                const queries = [];

                for (const [itemId, identifiers] of Object.entries(this.extractedIdentifiers)) {
                    // Item-level queries
                    for (const ark of identifiers.itemLevel.ark) {
                        queries.push({
                            itemId,
                            identifierType: 'ark',
                            identifier: ark,
                            query: this.buildSPARQLQuery('P8091', ark.value)
                        });
                    }

                    for (const oclc of identifiers.itemLevel.oclc) {
                        queries.push({
                            itemId,
                            identifierType: 'oclc',
                            identifier: oclc,
                            query: this.buildSPARQLQuery('P243', oclc.value)
                        });
                    }

                    // Value-level queries
                    for (const viaf of identifiers.valueLevel.viaf) {
                        queries.push({
                            itemId,
                            identifierType: 'viaf',
                            identifier: viaf,
                            query: this.buildSPARQLQuery('P214', viaf.value)
                        });
                    }

                    for (const geoname of identifiers.valueLevel.geonames) {
                        queries.push({
                            itemId,
                            identifierType: 'geonames',
                            identifier: geoname,
                            query: this.buildSPARQLQuery('P1566', geoname.value)
                        });
                    }

                    for (const lang of identifiers.valueLevel.iso639) {
                        const property = lang.type === 'ISO 639-1' ? 'P218' : 'P220';
                        queries.push({
                            itemId,
                            identifierType: 'iso639',
                            identifier: lang,
                            query: this.buildSPARQLQuery(property, lang.value)
                        });
                    }

                    // Direct QID matches don't need queries
                    for (const qid of identifiers.valueLevel.wikidataQids) {
                        if (!this.wikidataMatches[itemId]) {
                            this.wikidataMatches[itemId] = {};
                        }
                        if (!this.wikidataMatches[itemId]['wikidataQids']) {
                            this.wikidataMatches[itemId]['wikidataQids'] = [];
                        }
                        this.wikidataMatches[itemId]['wikidataQids'].push({
                            identifier: qid,
                            wikidataEntity: qid.value,
                            direct: true
                        });
                    }
                }

                // Execute all SPARQL queries in parallel
                const queryPromises = queries.map(queryInfo => 
                    this.executeSPARQLQuery(queryInfo.query)
                        .then(result => ({ ...queryInfo, result }))
                        .catch(error => ({ ...queryInfo, error }))
                );

                const results = await Promise.all(queryPromises);

                // Process results
                for (const queryResult of results) {
                    if (queryResult.error) {
                        console.error(`SPARQL query failed for ${queryResult.identifierType}:`, queryResult.error);
                        continue;
                    }

                    if (queryResult.result.results.bindings.length > 0) {
                        const wikidataEntity = this.extractEntityFromSPARQLResult(queryResult.result);
                        
                        if (!this.wikidataMatches[queryResult.itemId]) {
                            this.wikidataMatches[queryResult.itemId] = {};
                        }
                        if (!this.wikidataMatches[queryResult.itemId][queryResult.identifierType]) {
                            this.wikidataMatches[queryResult.itemId][queryResult.identifierType] = [];
                        }

                        this.wikidataMatches[queryResult.itemId][queryResult.identifierType].push({
                            identifier: queryResult.identifier,
                            wikidataEntity,
                            sparqlResult: queryResult.result
                        });

                        console.log(`‚úÖ Match found: ${queryResult.identifierType} ${queryResult.identifier.value} ‚Üí ${wikidataEntity}`);
                    }
                }
            }

            buildSPARQLQuery(property, value) {
                return `
                    SELECT ?item WHERE { 
                        ?item wdt:${property} "${value}" .
                    }
                    LIMIT 1
                `;
            }

            async executeSPARQLQuery(query) {
                const endpoint = 'https://query.wikidata.org/sparql';
                const url = new URL(endpoint);
                url.searchParams.set('query', query);
                url.searchParams.set('format', 'json');

                const response = await fetch(url.toString(), {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/sparql-results+json',
                        'User-Agent': 'Omeka-S-to-Wikidata-Tool/1.0'
                    }
                });

                if (!response.ok) {
                    throw new Error(`SPARQL query failed: ${response.status} ${response.statusText}`);
                }

                return await response.json();
            }

            extractEntityFromSPARQLResult(sparqlResult) {
                const bindings = sparqlResult.results.bindings;
                if (bindings.length === 0) return null;

                const itemUri = bindings[0].item.value;
                const match = itemUri.match(/\/entity\/([QP]\d+)$/);
                return match ? match[1] : null;
            }

            detectConflicts() {
                console.log('üîç Detecting identifier conflicts...');

                for (const [itemId, matches] of Object.entries(this.wikidataMatches)) {
                    const entitiesByField = {};
                    
                    for (const [identifierType, identifierMatches] of Object.entries(matches)) {
                        for (const match of identifierMatches) {
                            const field = match.identifier.source;
                            if (!entitiesByField[field]) {
                                entitiesByField[field] = [];
                            }
                            entitiesByField[field].push({
                                identifierType,
                                identifier: match.identifier,
                                wikidataEntity: match.wikidataEntity || match.identifier.value
                            });
                        }
                    }

                    for (const [field, matches] of Object.entries(entitiesByField)) {
                        if (matches.length > 1) {
                            const entities = [...new Set(matches.map(m => m.wikidataEntity))];
                            if (entities.length > 1) {
                                if (!this.conflicts[itemId]) {
                                    this.conflicts[itemId] = {};
                                }
                                this.conflicts[itemId][field] = matches;
                                console.log(`‚ö†Ô∏è  Conflict detected in item ${itemId}, field ${field}:`, entities);
                            }
                        }
                    }
                }
            }

            getStatistics() {
                const stats = {
                    totalItems: Object.keys(this.extractedIdentifiers).length,
                    identifierCounts: {},
                    matchCounts: {},
                    conflictCounts: Object.keys(this.conflicts).length
                };

                for (const identifiers of Object.values(this.extractedIdentifiers)) {
                    for (const [category, types] of Object.entries(identifiers)) {
                        for (const [type, items] of Object.entries(types)) {
                            const key = `${category}.${type}`;
                            stats.identifierCounts[key] = (stats.identifierCounts[key] || 0) + items.length;
                        }
                    }
                }

                for (const matches of Object.values(this.wikidataMatches)) {
                    for (const [type, items] of Object.entries(matches)) {
                        stats.matchCounts[type] = (stats.matchCounts[type] || 0) + items.length;
                    }
                }

                return stats;
            }
        }

        // Sample Omeka S data (from the uploaded file)
        const sampleData = [
            {
                "@context": "https://digitalcollections.library.maastrichtuniversity.nl/api-context",
                "@id": "https://digitalcollections.library.maastrichtuniversity.nl/api/items/30",
                "@type": ["o:Item", "schema:Book"],
                "o:id": 30,
                "o:title": "Eros op den Parnassus : minnepo√´zie uit alle tijden",
                "schema:name": [{
                    "type": "literal",
                    "property_id": 1451,
                    "property_label": "name",
                    "is_public": true,
                    "@value": "Eros op den Parnassus : minnepo√´zie uit alle tijden"
                }],
                "schema:author": [{
                    "type": "valuesuggest:ndeterms:wikipers",
                    "property_id": 903,
                    "property_label": "author",
                    "is_public": true,
                    "@id": "http://www.wikidata.org/entity/Q7925880",
                    "o:label": "Victor van Vriesland"
                }],
                "schema:locationCreated": [{
                    "type": "valuesuggest:geonames:geonames",
                    "property_id": 1216,
                    "property_label": "locationCreated",
                    "is_public": true,
                    "@id": "http://www.geonames.org/2759794",
                    "o:label": "Amsterdam"
                }],
                "schema:publisher": [{
                    "type": "valuesuggest:oclc:viaf",
                    "property_id": 1527,
                    "property_label": "publisher",
                    "is_public": true,
                    "@id": "http://viaf.org/viaf/172840804",
                    "o:label": "Contact Dutch publisher"
                }],
                "schema:inLanguage": [{
                    "type": "valuesuggest:lc:iso6391",
                    "property_id": 767,
                    "property_label": "inLanguage",
                    "is_public": true,
                    "@id": "http://id.loc.gov/vocabulary/iso639-1/nl",
                    "o:label": "Dutch |  Flemish"
                }],
                "schema:sameAs": [{
                    "type": "uri",
                    "property_id": 1132,
                    "property_label": "sameAs",
                    "is_public": true,
                    "@id": "https://maastrichtuniversity.on.worldcat.org/oclc/65042490"
                }],
                "schema:license": [{
                    "type": "uri",
                    "property_id": 1574,
                    "property_label": "license",
                    "is_public": true,
                    "@id": "https://www.wikidata.org/wiki/Q20007257",
                    "o:label": "CC-BY 4.0"
                }],
                "schema:provider": [{
                    "type": "uri",
                    "property_id": 1499,
                    "property_label": "provider",
                    "is_public": true,
                    "@id": "https://www.wikidata.org/entity/Q15734302",
                    "o:label": "Maastricht University Library"
                }],
                "dcterms:identifier": [{
                    "type": "literal",
                    "property_id": 10,
                    "property_label": "Identifier",
                    "is_public": true,
                    "@value": "ark:/27364/d1n4b0E"
                }]
            },
            {
                "@context": "https://digitalcollections.library.maastrichtuniversity.nl/api-context",
                "@id": "https://digitalcollections.library.maastrichtuniversity.nl/api/items/32",
                "@type": ["o:Item", "schema:Book"],
                "o:id": 32,
                "o:title": "Anthologie de la nouvelle po√©sie fran√ßaise",
                "schema:name": [{
                    "type": "literal",
                    "property_id": 1451,
                    "property_label": "name",
                    "is_public": true,
                    "@value": "Anthologie de la nouvelle po√©sie fran√ßaise"
                }],
                "schema:locationCreated": [{
                    "type": "valuesuggest:geonames:geonames",
                    "property_id": 1216,
                    "property_label": "locationCreated",
                    "is_public": true,
                    "@id": "http://www.geonames.org/2988507",
                    "o:label": "Paris"
                }],
                "schema:publisher": [{
                    "type": "valuesuggest:oclc:viaf",
                    "property_id": 1527,
                    "property_label": "publisher",
                    "is_public": true,
                    "@id": "http://viaf.org/viaf/200887528",
                    "o:label": "√âditions du Sagittaire"
                }],
                "schema:inLanguage": [{
                    "type": "valuesuggest:lc:iso6391",
                    "property_id": 767,
                    "property_label": "inLanguage",
                    "is_public": true,
                    "@id": "http://id.loc.gov/vocabulary/iso639-1/fr",
                    "o:label": "French"
                }],
                "schema:sameAs": [{
                    "type": "uri",
                    "property_id": 1132,
                    "property_label": "sameAs",
                    "is_public": true,
                    "@id": "https://maastrichtuniversity.on.worldcat.org/oclc/33063658"
                }],
                "schema:license": [{
                    "type": "uri",
                    "property_id": 1574,
                    "property_label": "license",
                    "is_public": true,
                    "@id": "https://www.wikidata.org/wiki/Q20007257",
                    "o:label": "CC-BY 4.0"
                }],
                "schema:provider": [{
                    "type": "uri",
                    "property_id": 1499,
                    "property_label": "provider",
                    "is_public": true,
                    "@id": "https://www.wikidata.org/entity/Q15734302",
                    "o:label": "Maastricht University Library"
                }],
                "dcterms:identifier": [{
                    "type": "literal",
                    "property_id": 10,
                    "property_label": "Identifier",
                    "is_public": true,
                    "@value": "ark:/27364/d1e9AQE"
                }]
            }
        ];

        let detectionResults = null;
        let detection = null;

        // Event listeners
        document.getElementById('runDetection').addEventListener('click', runIdentifierDetection);
        document.getElementById('showSampleData').addEventListener('click', showSampleData);
        document.getElementById('testApiCalls').addEventListener('click', testApiCalls);

        async function runIdentifierDetection() {
            const loadingElement = document.getElementById('loadingIndicator');
            const errorContainer = document.getElementById('errorContainer');
            const progressFill = document.getElementById('progressFill');

            try {
                // Show loading
                loadingElement.style.display = 'block';
                errorContainer.style.display = 'none';
                hideAllContainers();
                
                // Animate progress
                let progress = 0;
                const progressInterval = setInterval(() => {
                    progress += 10;
                    progressFill.style.width = Math.min(progress, 90) + '%';
                }, 200);

                // Run detection
                detection = new IdentifierDetection();
                detectionResults = await detection.processItems(sampleData);

                // Complete progress
                clearInterval(progressInterval);
                progressFill.style.width = '100%';

                // Hide loading
                setTimeout(() => {
                    loadingElement.style.display = 'none';
                    showResults();
                }, 500);

            } catch (error) {
                console.error('Detection failed:', error);
                loadingElement.style.display = 'none';
                showError('Identifier detection failed: ' + error.message);
            }
        }

        function showResults() {
            if (!detectionResults || !detection) return;

            showStatistics();
            showDetectionResults();
            showConflicts();
        }

        function showStatistics() {
            const stats = detection.getStatistics();
            const statsContainer = document.getElementById('statsContainer');
            const statsContent = document.getElementById('statsContent');

            let statsHtml = '';
            
            // Overall stats
            statsHtml += `
                <div class="stat-card">
                    <span class="stat-number">${stats.totalItems}</span>
                    <div class="stat-label">Total Items</div>
                </div>
                <div class="stat-card">
                    <span class="stat-number">${stats.conflictCounts}</span>
                    <div class="stat-label">Conflicts</div>
                </div>
            `;

            // Identifier counts
            for (const [type, count] of Object.entries(stats.identifierCounts)) {
                if (count > 0) {
                    statsHtml += `
                        <div class="stat-card">
                            <span class="stat-number">${count}</span>
                            <div class="stat-label">${type.replace('.', ' ')}</div>
                        </div>
                    `;
                }
            }

            // Match counts
            for (const [type, count] of Object.entries(stats.matchCounts)) {
                if (count > 0) {
                    statsHtml += `
                        <div class="stat-card">
                            <span class="stat-number">${count}</span>
                            <div class="stat-label">${type} matches</div>
                        </div>
                    `;
                }
            }

            statsContent.innerHTML = statsHtml;
            statsContainer.style.display = 'block';
        }

        function showDetectionResults() {
            const resultsContainer = document.getElementById('resultsContainer');
            const resultsContent = document.getElementById('resultsContent');

            let resultsHtml = '';

            for (const [itemId, identifiers] of Object.entries(detectionResults.extractedIdentifiers)) {
                const item = sampleData.find(item => item['o:id'] == itemId);
                const matches = detectionResults.wikidataMatches[itemId] || {};
                const conflicts = detectionResults.conflicts[itemId] || {};

                resultsHtml += `
                    <div class="item-card">
                        <div class="item-title">
                            ${item['o:title']} (ID: ${itemId})
                        </div>
                `;

                // Item-level identifiers
                resultsHtml += '<h3>Item-Level Identifiers</h3>';
                
                // ARK
                if (identifiers.itemLevel.ark.length > 0) {
                    resultsHtml += '<div class="identifier-type"><h4>ARK (P8091)</h4><ul class="identifier-list">';
                    for (const ark of identifiers.itemLevel.ark) {
                        const match = matches.ark?.find(m => m.identifier === ark);
                        const cssClass = match ? 'matched' : '';
                        resultsHtml += `<li class="identifier-item ${cssClass}">${ark.value}`;
                        if (match) {
                            resultsHtml += `<div class="wikidata-match">‚Üí <a href="https://www.wikidata.org/wiki/${match.wikidataEntity}" target="_blank">${match.wikidataEntity}</a></div>`;
                        }
                        resultsHtml += '</li>';
                    }
                    resultsHtml += '</ul></div>';
                }

                // OCLC
                if (identifiers.itemLevel.oclc.length > 0) {
                    resultsHtml += '<div class="identifier-type"><h4>OCLC (P243)</h4><ul class="identifier-list">';
                    for (const oclc of identifiers.itemLevel.oclc) {
                        const match = matches.oclc?.find(m => m.identifier === oclc);
                        const cssClass = match ? 'matched' : '';
                        resultsHtml += `<li class="identifier-item ${cssClass}">${oclc.value}`;
                        if (match) {
                            resultsHtml += `<div class="wikidata-match">‚Üí <a href="https://www.wikidata.org/wiki/${match.wikidataEntity}" target="_blank">${match.wikidataEntity}</a></div>`;
                        }
                        resultsHtml += '</li>';
                    }
                    resultsHtml += '</ul></div>';
                }

                // Value-level identifiers
                resultsHtml += '<h3>Value-Level Identifiers</h3>';

                // VIAF
                if (identifiers.valueLevel.viaf.length > 0) {
                    resultsHtml += '<div class="identifier-type"><h4>VIAF (P214)</h4><ul class="identifier-list">';
                    for (const viaf of identifiers.valueLevel.viaf) {
                        const match = matches.viaf?.find(m => m.identifier === viaf);
                        const cssClass = match ? 'matched' : '';
                        resultsHtml += `<li class="identifier-item ${cssClass}">${viaf.value} (${viaf.source})`;
                        if (viaf.label) resultsHtml += ` - ${viaf.label}`;
                        if (match) {
                            resultsHtml += `<div class="wikidata-match">‚Üí <a href="https://www.wikidata.org/wiki/${match.wikidataEntity}" target="_blank">${match.wikidataEntity}</a></div>`;
                        }
                        resultsHtml += '</li>';
                    }
                    resultsHtml += '</ul></div>';
                }

                // GeoNames
                if (identifiers.valueLevel.geonames.length > 0) {
                    resultsHtml += '<div class="identifier-type"><h4>GeoNames (P1566)</h4><ul class="identifier-list">';
                    for (const geoname of identifiers.valueLevel.geonames) {
                        const match = matches.geonames?.find(m => m.identifier === geoname);
                        const cssClass = match ? 'matched' : '';
                        resultsHtml += `<li class="identifier-item ${cssClass}">${geoname.value} (${geoname.source})`;
                        if (geoname.label) resultsHtml += ` - ${geoname.label}`;
                        if (match) {
                            resultsHtml += `<div class="wikidata-match">‚Üí <a href="https://www.wikidata.org/wiki/${match.wikidataEntity}" target="_blank">${match.wikidataEntity}</a></div>`;
                        }
                        resultsHtml += '</li>';
                    }
                    resultsHtml += '</ul></div>';
                }

                // Language codes
                if (identifiers.valueLevel.iso639.length > 0) {
                    resultsHtml += '<div class="identifier-type"><h4>Language Codes (P218/P220)</h4><ul class="identifier-list">';
                    for (const lang of identifiers.valueLevel.iso639) {
                        const match = matches.iso639?.find(m => m.identifier === lang);
                        const cssClass = match ? 'matched' : '';
                        resultsHtml += `<li class="identifier-item ${cssClass}">${lang.value} (${lang.type})`;
                        if (lang.label) resultsHtml += ` - ${lang.label}`;
                        if (match) {
                            resultsHtml += `<div class="wikidata-match">‚Üí <a href="https://www.wikidata.org/wiki/${match.wikidataEntity}" target="_blank">${match.wikidataEntity}</a></div>`;
                        }
                        resultsHtml += '</li>';
                    }
                    resultsHtml += '</ul></div>';
                }

                // Direct Wikidata QIDs
                if (identifiers.valueLevel.wikidataQids.length > 0) {
                    resultsHtml += '<div class="identifier-type"><h4>Direct Wikidata QIDs</h4><ul class="identifier-list">';
                    for (const qid of identifiers.valueLevel.wikidataQids) {
                        resultsHtml += `<li class="identifier-item matched">${qid.value} (${qid.source})`;
                        if (qid.label) resultsHtml += ` - ${qid.label}`;
                        resultsHtml += `<div class="wikidata-match">‚Üí <a href="https://www.wikidata.org/wiki/${qid.value}" target="_blank">${qid.value}</a> (Direct)</div>`;
                        resultsHtml += '</li>';
                    }
                    resultsHtml += '</ul></div>';
                }

                resultsHtml += '</div>';
            }

            resultsContent.innerHTML = resultsHtml;
            resultsContainer.style.display = 'block';
        }

        function showConflicts() {
            const conflictsContainer = document.getElementById('conflictsContainer');
            const conflictsContent = document.getElementById('conflictsContent');

            if (Object.keys(detectionResults.conflicts).length === 0) {
                conflictsContent.innerHTML = '<div class="success">‚úÖ No conflicts detected! All identifiers point to consistent Wikidata entities.</div>';
                conflictsContainer.style.display = 'block';
                return;
            }

            let conflictsHtml = '';

            for (const [itemId, fieldConflicts] of Object.entries(detectionResults.conflicts)) {
                const item = sampleData.find(item => item['o:id'] == itemId);
                
                conflictsHtml += `
                    <div class="item-card">
                        <div class="item-title">${item['o:title']} (ID: ${itemId})</div>
                `;

                for (const [field, matches] of Object.entries(fieldConflicts)) {
                    conflictsHtml += `
                        <div class="identifier-type">
                            <h4>${field} <span class="conflict-indicator">CONFLICT</span></h4>
                            <ul class="identifier-list">
                    `;

                    for (const match of matches) {
                        conflictsHtml += `
                            <li class="identifier-item conflict">
                                ${match.identifierType}: ${match.identifier.value} 
                                ‚Üí <a href="https://www.wikidata.org/wiki/${match.wikidataEntity}" target="_blank">${match.wikidataEntity}</a>
                            </li>
                        `;
                    }

                    conflictsHtml += '</ul></div>';
                }

                conflictsHtml += '</div>';
            }

            conflictsContent.innerHTML = conflictsHtml;
            conflictsContainer.style.display = 'block';
        }

        function showSampleData() {
            const container = document.getElementById('sampleDataContainer');
            const content = document.getElementById('sampleDataContent');
            
            content.textContent = JSON.stringify(sampleData, null, 2);
            container.style.display = 'block';
        }

        async function testApiCalls() {
            const container = document.getElementById('apiTestContainer');
            const results = document.getElementById('apiTestResults');
            
            container.style.display = 'block';
            results.innerHTML = '<div class="loading">Testing API calls...</div>';

            let testHtml = '<h3>üîß SPARQL API Tests</h3>';

            // Test queries
            const testQueries = [
                { type: 'GeoNames', property: 'P1566', value: '2759794', description: 'Amsterdam' },
                { type: 'VIAF', property: 'P214', value: '172840804', description: 'Contact Dutch publisher' },
                { type: 'OCLC', property: 'P243', value: '65042490', description: 'WorldCat OCLC' },
                { type: 'Language', property: 'P218', value: 'nl', description: 'Dutch language' },
            ];

            for (const test of testQueries) {
                try {
                    const query = `SELECT ?item WHERE { ?item wdt:${test.property} "${test.value}" . } LIMIT 1`;
                    const endpoint = 'https://query.wikidata.org/sparql';
                    const url = new URL(endpoint);
                    url.searchParams.set('query', query);
                    url.searchParams.set('format', 'json');

                    const response = await fetch(url.toString(), {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/sparql-results+json',
                            'User-Agent': 'Omeka-S-to-Wikidata-Tool/1.0'
                        }
                    });

                    if (response.ok) {
                        const data = await response.json();
                        const hasResults = data.results.bindings.length > 0;
                        const entity = hasResults ? data.results.bindings[0].item.value.match(/\/entity\/([QP]\d+)$/)?.[1] : null;
                        
                        testHtml += `
                            <div class="identifier-item ${hasResults ? 'matched' : ''}">
                                ${test.type} (${test.property}): ${test.value} - ${test.description}
                                <span class="api-status ${hasResults ? 'success' : 'error'}">${hasResults ? '‚úÖ MATCH' : '‚ùå NO MATCH'}</span>
                                ${entity ? `<div class="wikidata-match">‚Üí <a href="https://www.wikidata.org/wiki/${entity}" target="_blank">${entity}</a></div>` : ''}
                            </div>
                        `;
                    } else {
                        testHtml += `
                            <div class="identifier-item error">
                                ${test.type} (${test.property}): ${test.value} - ${test.description}
                                <span class="api-status error">‚ùå API ERROR (${response.status})</span>
                            </div>
                        `;
                    }
                } catch (error) {
                    testHtml += `
                        <div class="identifier-item error">
                            ${test.type} (${test.property}): ${test.value} - ${test.description}
                            <span class="api-status error">‚ùå NETWORK ERROR</span>
                        </div>
                    `;
                }
            }

            results.innerHTML = testHtml;
        }

        function showError(message) {
            const errorContainer = document.getElementById('errorContainer');
            errorContainer.innerHTML = `<div class="error">‚ùå ${message}</div>`;
            errorContainer.style.display = 'block';
        }

        function hideAllContainers() {
            const containers = ['sampleDataContainer', 'apiTestContainer', 'statsContainer', 'resultsContainer', 'conflictsContainer'];
            containers.forEach(id => {
                document.getElementById(id).style.display = 'none';
            });
        }

        // Show sample data on load for convenience
        showSampleData();
    </script>
</body>
</html>